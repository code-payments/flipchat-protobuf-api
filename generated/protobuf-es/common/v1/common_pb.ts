// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file common/v1/common.proto (package flipchat.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum flipchat.common.v1.Platform
 */
export enum Platform {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: APPLE = 1;
   */
  APPLE = 1,

  /**
   * @generated from enum value: GOOGLE = 2;
   */
  GOOGLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Platform)
proto3.util.setEnumType(Platform, "flipchat.common.v1.Platform", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "APPLE" },
  { no: 2, name: "GOOGLE" },
]);

/**
 * Auth provides an authentication information for RPCs/messages.
 *
 * Currently, only a single form is supported, but it may be useful in
 * the future to rely on session tokens instead.
 *
 * @generated from message flipchat.common.v1.Auth
 */
export class Auth extends Message<Auth> {
  /**
   * @generated from oneof flipchat.common.v1.Auth.kind
   */
  kind: {
    /**
     * KeyPair uses pub key cryptography to verify.
     *
     * @generated from field: flipchat.common.v1.Auth.KeyPair key_pair = 1;
     */
    value: Auth_KeyPair;
    case: "keyPair";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Auth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.Auth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_pair", kind: "message", T: Auth_KeyPair, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth {
    return new Auth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJsonString(jsonString, options);
  }

  static equals(a: Auth | PlainMessage<Auth> | undefined, b: Auth | PlainMessage<Auth> | undefined): boolean {
    return proto3.util.equals(Auth, a, b);
  }
}

/**
 * KeyPair uses a keypair to verify a message.
 *
 * The signature should be of the encapsulating proto message,
 * _without_ the Auth section being set.
 *
 * @generated from message flipchat.common.v1.Auth.KeyPair
 */
export class Auth_KeyPair extends Message<Auth_KeyPair> {
  /**
   * @generated from field: flipchat.common.v1.PublicKey pub_key = 1;
   */
  pubKey?: PublicKey;

  /**
   * @generated from field: flipchat.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<Auth_KeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.Auth.KeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pub_key", kind: "message", T: PublicKey },
    { no: 2, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: Auth_KeyPair | PlainMessage<Auth_KeyPair> | undefined, b: Auth_KeyPair | PlainMessage<Auth_KeyPair> | undefined): boolean {
    return proto3.util.equals(Auth_KeyPair, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.UserId
 */
export class UserId extends Message<UserId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<UserId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.UserId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserId {
    return new UserId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserId {
    return new UserId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserId {
    return new UserId().fromJsonString(jsonString, options);
  }

  static equals(a: UserId | PlainMessage<UserId> | undefined, b: UserId | PlainMessage<UserId> | undefined): boolean {
    return proto3.util.equals(UserId, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.ChatId
 */
export class ChatId extends Message<ChatId> {
  /**
   * Sufficient space is left for a consistent hash value, though other types
   * of values may be used.
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<ChatId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.ChatId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatId {
    return new ChatId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatId {
    return new ChatId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatId {
    return new ChatId().fromJsonString(jsonString, options);
  }

  static equals(a: ChatId | PlainMessage<ChatId> | undefined, b: ChatId | PlainMessage<ChatId> | undefined): boolean {
    return proto3.util.equals(ChatId, a, b);
  }
}

/**
 * AppInstallId is a unque ID tied to a client app installation. It does not
 * identify a device. Value should remain private and not be shared across
 * installs.
 *
 * @generated from message flipchat.common.v1.AppInstallId
 */
export class AppInstallId extends Message<AppInstallId> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<AppInstallId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.AppInstallId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppInstallId {
    return new AppInstallId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppInstallId {
    return new AppInstallId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppInstallId {
    return new AppInstallId().fromJsonString(jsonString, options);
  }

  static equals(a: AppInstallId | PlainMessage<AppInstallId> | undefined, b: AppInstallId | PlainMessage<AppInstallId> | undefined): boolean {
    return proto3.util.equals(AppInstallId, a, b);
  }
}

/**
 * Locale is a user locale consisting of a combination of language, script and region
 *
 * @generated from message flipchat.common.v1.Locale
 */
export class Locale extends Message<Locale> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<Locale>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.Locale";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Locale {
    return new Locale().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Locale {
    return new Locale().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Locale {
    return new Locale().fromJsonString(jsonString, options);
  }

  static equals(a: Locale | PlainMessage<Locale> | undefined, b: Locale | PlainMessage<Locale> | undefined): boolean {
    return proto3.util.equals(Locale, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.PublicKey
 */
export class PublicKey extends Message<PublicKey> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<PublicKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.PublicKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey {
    return new PublicKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJsonString(jsonString, options);
  }

  static equals(a: PublicKey | PlainMessage<PublicKey> | undefined, b: PublicKey | PlainMessage<PublicKey> | undefined): boolean {
    return proto3.util.equals(PublicKey, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.IntentId
 */
export class IntentId extends Message<IntentId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<IntentId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.IntentId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntentId {
    return new IntentId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntentId {
    return new IntentId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntentId {
    return new IntentId().fromJsonString(jsonString, options);
  }

  static equals(a: IntentId | PlainMessage<IntentId> | undefined, b: IntentId | PlainMessage<IntentId> | undefined): boolean {
    return proto3.util.equals(IntentId, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.Signature
 */
export class Signature extends Message<Signature> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Signature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.Signature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signature {
    return new Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJsonString(jsonString, options);
  }

  static equals(a: Signature | PlainMessage<Signature> | undefined, b: Signature | PlainMessage<Signature> | undefined): boolean {
    return proto3.util.equals(Signature, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.PaymentAmount
 */
export class PaymentAmount extends Message<PaymentAmount> {
  /**
   * @generated from field: uint64 quarks = 1;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<PaymentAmount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.PaymentAmount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentAmount {
    return new PaymentAmount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentAmount {
    return new PaymentAmount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentAmount {
    return new PaymentAmount().fromJsonString(jsonString, options);
  }

  static equals(a: PaymentAmount | PlainMessage<PaymentAmount> | undefined, b: PaymentAmount | PlainMessage<PaymentAmount> | undefined): boolean {
    return proto3.util.equals(PaymentAmount, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.ServerPing
 */
export class ServerPing extends Message<ServerPing> {
  /**
   * Timestamp the ping was sent on the stream, for client to get a sense
   * of potential network latency
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The delay server will apply before sending the next ping
   *
   * @generated from field: google.protobuf.Duration ping_delay = 2;
   */
  pingDelay?: Duration;

  constructor(data?: PartialMessage<ServerPing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.ServerPing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "ping_delay", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerPing {
    return new ServerPing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerPing {
    return new ServerPing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerPing {
    return new ServerPing().fromJsonString(jsonString, options);
  }

  static equals(a: ServerPing | PlainMessage<ServerPing> | undefined, b: ServerPing | PlainMessage<ServerPing> | undefined): boolean {
    return proto3.util.equals(ServerPing, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.ClientPong
 */
export class ClientPong extends Message<ClientPong> {
  /**
   * Timestamp the Pong was sent on the stream, for server to get a sense
   * of potential network latency
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ClientPong>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.ClientPong";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientPong {
    return new ClientPong().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientPong {
    return new ClientPong().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientPong {
    return new ClientPong().fromJsonString(jsonString, options);
  }

  static equals(a: ClientPong | PlainMessage<ClientPong> | undefined, b: ClientPong | PlainMessage<ClientPong> | undefined): boolean {
    return proto3.util.equals(ClientPong, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.PagingToken
 */
export class PagingToken extends Message<PagingToken> {
  /**
   * Value contains a value of an identifier of the collection in common.
   *
   * For example, GetChats uses the ChatId.Value, where GetMessages uses MessageId.Value
   * as the contents. It does _not_ contain the serialized ChatId or MessageId.
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<PagingToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.PagingToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PagingToken {
    return new PagingToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PagingToken {
    return new PagingToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PagingToken {
    return new PagingToken().fromJsonString(jsonString, options);
  }

  static equals(a: PagingToken | PlainMessage<PagingToken> | undefined, b: PagingToken | PlainMessage<PagingToken> | undefined): boolean {
    return proto3.util.equals(PagingToken, a, b);
  }
}

/**
 * @generated from message flipchat.common.v1.QueryOptions
 */
export class QueryOptions extends Message<QueryOptions> {
  /**
   * PageSize limits the maximum page size of a response.
   *
   * Server may choose to return less items. If empty, server
   * may select an arbitrary page size.
   *
   * @generated from field: int64 page_size = 1;
   */
  pageSize = protoInt64.zero;

  /**
   * PagingToken is token that can be extracted from the identifier of a collection.
   *
   * @generated from field: flipchat.common.v1.PagingToken paging_token = 2;
   */
  pagingToken?: PagingToken;

  /**
   * Order is the order of elements, if applicable.
   *
   * @generated from field: flipchat.common.v1.QueryOptions.Order order = 3;
   */
  order = QueryOptions_Order.ASC;

  constructor(data?: PartialMessage<QueryOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.common.v1.QueryOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "paging_token", kind: "message", T: PagingToken },
    { no: 3, name: "order", kind: "enum", T: proto3.getEnumType(QueryOptions_Order) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryOptions {
    return new QueryOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryOptions {
    return new QueryOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryOptions {
    return new QueryOptions().fromJsonString(jsonString, options);
  }

  static equals(a: QueryOptions | PlainMessage<QueryOptions> | undefined, b: QueryOptions | PlainMessage<QueryOptions> | undefined): boolean {
    return proto3.util.equals(QueryOptions, a, b);
  }
}

/**
 * @generated from enum flipchat.common.v1.QueryOptions.Order
 */
export enum QueryOptions_Order {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryOptions_Order)
proto3.util.setEnumType(QueryOptions_Order, "flipchat.common.v1.QueryOptions.Order", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

