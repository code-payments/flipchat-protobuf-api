// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file chat/v1/chat_service.proto (package flipchat.chat.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Auth, ChatId, ClientPong, IntentId, PagingToken, PaymentAmount, QueryOptions, ServerPing, UserId } from "../../common/v1/common_pb";
import { IsTyping, Message as Message$1, MessageId, Pointer } from "../../messaging/v1/model_pb";
import { SocialProfile } from "../../profile/v1/model_pb";

/**
 * @generated from message flipchat.chat.v1.StreamChatEventsRequest
 */
export class StreamChatEventsRequest extends Message<StreamChatEventsRequest> {
  /**
   * @generated from oneof flipchat.chat.v1.StreamChatEventsRequest.type
   */
  type: {
    /**
     * @generated from field: flipchat.chat.v1.StreamChatEventsRequest.Params params = 1;
     */
    value: StreamChatEventsRequest_Params;
    case: "params";
  } | {
    /**
     * @generated from field: flipchat.common.v1.ClientPong pong = 2;
     */
    value: ClientPong;
    case: "pong";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamChatEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: StreamChatEventsRequest_Params, oneof: "type" },
    { no: 2, name: "pong", kind: "message", T: ClientPong, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsRequest | PlainMessage<StreamChatEventsRequest> | undefined, b: StreamChatEventsRequest | PlainMessage<StreamChatEventsRequest> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.StreamChatEventsRequest.Params
 */
export class StreamChatEventsRequest_Params extends Message<StreamChatEventsRequest_Params> {
  /**
   * @generated from field: flipchat.common.v1.Auth auth = 1;
   */
  auth?: Auth;

  /**
   * ts contains the time for stream open.
   *
   * It is used primarily as a nonce for auth. Server may reject
   * timestamps that are too far in the future or past.
   *
   * @generated from field: google.protobuf.Timestamp ts = 2;
   */
  ts?: Timestamp;

  constructor(data?: PartialMessage<StreamChatEventsRequest_Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsRequest.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auth", kind: "message", T: Auth },
    { no: 2, name: "ts", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsRequest_Params {
    return new StreamChatEventsRequest_Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsRequest_Params {
    return new StreamChatEventsRequest_Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsRequest_Params {
    return new StreamChatEventsRequest_Params().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsRequest_Params | PlainMessage<StreamChatEventsRequest_Params> | undefined, b: StreamChatEventsRequest_Params | PlainMessage<StreamChatEventsRequest_Params> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsRequest_Params, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.StreamChatEventsResponse
 */
export class StreamChatEventsResponse extends Message<StreamChatEventsResponse> {
  /**
   * @generated from oneof flipchat.chat.v1.StreamChatEventsResponse.type
   */
  type: {
    /**
     * @generated from field: flipchat.common.v1.ServerPing ping = 1;
     */
    value: ServerPing;
    case: "ping";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.StreamChatEventsResponse.StreamError error = 2;
     */
    value: StreamChatEventsResponse_StreamError;
    case: "error";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.StreamChatEventsResponse.EventBatch events = 3;
     */
    value: StreamChatEventsResponse_EventBatch;
    case: "events";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamChatEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ping", kind: "message", T: ServerPing, oneof: "type" },
    { no: 2, name: "error", kind: "message", T: StreamChatEventsResponse_StreamError, oneof: "type" },
    { no: 3, name: "events", kind: "message", T: StreamChatEventsResponse_EventBatch, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse | PlainMessage<StreamChatEventsResponse> | undefined, b: StreamChatEventsResponse | PlainMessage<StreamChatEventsResponse> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.StreamChatEventsResponse.StreamError
 */
export class StreamChatEventsResponse_StreamError extends Message<StreamChatEventsResponse_StreamError> {
  /**
   * @generated from field: flipchat.chat.v1.StreamChatEventsResponse.StreamError.Code code = 1;
   */
  code = StreamChatEventsResponse_StreamError_Code.DENIED;

  constructor(data?: PartialMessage<StreamChatEventsResponse_StreamError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsResponse.StreamError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(StreamChatEventsResponse_StreamError_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse_StreamError {
    return new StreamChatEventsResponse_StreamError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_StreamError {
    return new StreamChatEventsResponse_StreamError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_StreamError {
    return new StreamChatEventsResponse_StreamError().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse_StreamError | PlainMessage<StreamChatEventsResponse_StreamError> | undefined, b: StreamChatEventsResponse_StreamError | PlainMessage<StreamChatEventsResponse_StreamError> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse_StreamError, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.StreamChatEventsResponse.StreamError.Code
 */
export enum StreamChatEventsResponse_StreamError_Code {
  /**
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(StreamChatEventsResponse_StreamError_Code)
proto3.util.setEnumType(StreamChatEventsResponse_StreamError_Code, "flipchat.chat.v1.StreamChatEventsResponse.StreamError.Code", [
  { no: 0, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.StreamChatEventsResponse.EventBatch
 */
export class StreamChatEventsResponse_EventBatch extends Message<StreamChatEventsResponse_EventBatch> {
  /**
   * @generated from field: repeated flipchat.chat.v1.StreamChatEventsResponse.ChatUpdate updates = 1;
   */
  updates: StreamChatEventsResponse_ChatUpdate[] = [];

  constructor(data?: PartialMessage<StreamChatEventsResponse_EventBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsResponse.EventBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updates", kind: "message", T: StreamChatEventsResponse_ChatUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse_EventBatch {
    return new StreamChatEventsResponse_EventBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_EventBatch {
    return new StreamChatEventsResponse_EventBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_EventBatch {
    return new StreamChatEventsResponse_EventBatch().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse_EventBatch | PlainMessage<StreamChatEventsResponse_EventBatch> | undefined, b: StreamChatEventsResponse_EventBatch | PlainMessage<StreamChatEventsResponse_EventBatch> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse_EventBatch, a, b);
  }
}

/**
 * ChatUpdate contains a set of updates for a given chat id.
 *
 * Only the relevant fields will be set on update. On initial
 * stream open, all fields will be set, however.
 *
 * @generated from message flipchat.chat.v1.StreamChatEventsResponse.ChatUpdate
 */
export class StreamChatEventsResponse_ChatUpdate extends Message<StreamChatEventsResponse_ChatUpdate> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * Metadata contains the latest (full) chat metadata.
   *
   * Deprecated: Use metadata_updates instead. For backwards compatibility
   * this will only contain full metadata refreshes.
   *
   * @generated from field: flipchat.chat.v1.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * MetadataUpdate contains updates to a chat metadata
   *
   * @generated from field: repeated flipchat.chat.v1.MetadataUpdate metadata_updates = 7;
   */
  metadataUpdates: MetadataUpdate[] = [];

  /**
   * MemberUpdate contains an update to the membership set.
   *
   * Deprecated: Use member_updates instead. For backwards compatibility
   * this will only contain full member refreshes.
   *
   * @generated from field: flipchat.chat.v1.MemberUpdate member_update = 3;
   */
  memberUpdate?: MemberUpdate;

  /**
   * MemberUpdate contains updates to the membership set.
   *
   * @generated from field: repeated flipchat.chat.v1.MemberUpdate member_updates = 8;
   */
  memberUpdates: MemberUpdate[] = [];

  /**
   * Message contains the last known message of the chat.
   *
   * @generated from field: flipchat.messaging.v1.Message last_message = 4;
   */
  lastMessage?: Message$1;

  /**
   * Relevant update to a chat member's pointer state, where 'relevant' means
   * "relevant to UI updates". For example, when a user has read the latest
   * message.
   *
   * @generated from field: flipchat.chat.v1.StreamChatEventsResponse.ChatUpdate.PointerUpdate pointer = 5;
   */
  pointer?: StreamChatEventsResponse_ChatUpdate_PointerUpdate;

  /**
   * IsTyping indicates whether or not someone is typing in the group.
   *
   * @generated from field: flipchat.messaging.v1.IsTyping is_typing = 6;
   */
  isTyping?: IsTyping;

  constructor(data?: PartialMessage<StreamChatEventsResponse_ChatUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsResponse.ChatUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
    { no: 7, name: "metadata_updates", kind: "message", T: MetadataUpdate, repeated: true },
    { no: 3, name: "member_update", kind: "message", T: MemberUpdate },
    { no: 8, name: "member_updates", kind: "message", T: MemberUpdate, repeated: true },
    { no: 4, name: "last_message", kind: "message", T: Message$1 },
    { no: 5, name: "pointer", kind: "message", T: StreamChatEventsResponse_ChatUpdate_PointerUpdate },
    { no: 6, name: "is_typing", kind: "message", T: IsTyping },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse_ChatUpdate {
    return new StreamChatEventsResponse_ChatUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_ChatUpdate {
    return new StreamChatEventsResponse_ChatUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_ChatUpdate {
    return new StreamChatEventsResponse_ChatUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse_ChatUpdate | PlainMessage<StreamChatEventsResponse_ChatUpdate> | undefined, b: StreamChatEventsResponse_ChatUpdate | PlainMessage<StreamChatEventsResponse_ChatUpdate> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse_ChatUpdate, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.StreamChatEventsResponse.ChatUpdate.PointerUpdate
 */
export class StreamChatEventsResponse_ChatUpdate_PointerUpdate extends Message<StreamChatEventsResponse_ChatUpdate_PointerUpdate> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  /**
   * @generated from field: flipchat.messaging.v1.Pointer pointer = 2;
   */
  pointer?: Pointer;

  constructor(data?: PartialMessage<StreamChatEventsResponse_ChatUpdate_PointerUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StreamChatEventsResponse.ChatUpdate.PointerUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
    { no: 2, name: "pointer", kind: "message", T: Pointer },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse_ChatUpdate_PointerUpdate {
    return new StreamChatEventsResponse_ChatUpdate_PointerUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_ChatUpdate_PointerUpdate {
    return new StreamChatEventsResponse_ChatUpdate_PointerUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse_ChatUpdate_PointerUpdate {
    return new StreamChatEventsResponse_ChatUpdate_PointerUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse_ChatUpdate_PointerUpdate | PlainMessage<StreamChatEventsResponse_ChatUpdate_PointerUpdate> | undefined, b: StreamChatEventsResponse_ChatUpdate_PointerUpdate | PlainMessage<StreamChatEventsResponse_ChatUpdate_PointerUpdate> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse_ChatUpdate_PointerUpdate, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.GetChatsRequest
 */
export class GetChatsRequest extends Message<GetChatsRequest> {
  /**
   * @generated from field: flipchat.common.v1.QueryOptions query_options = 1;
   */
  queryOptions?: QueryOptions;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<GetChatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.GetChatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_options", kind: "message", T: QueryOptions },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined, b: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined): boolean {
    return proto3.util.equals(GetChatsRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.GetChatsResponse
 */
export class GetChatsResponse extends Message<GetChatsResponse> {
  /**
   * @generated from field: flipchat.chat.v1.GetChatsResponse.Result result = 1;
   */
  result = GetChatsResponse_Result.OK;

  /**
   * @generated from field: repeated flipchat.chat.v1.Metadata chats = 2;
   */
  chats: Metadata[] = [];

  constructor(data?: PartialMessage<GetChatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.GetChatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetChatsResponse_Result) },
    { no: 2, name: "chats", kind: "message", T: Metadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined, b: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined): boolean {
    return proto3.util.equals(GetChatsResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.GetChatsResponse.Result
 */
export enum GetChatsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsResponse_Result)
proto3.util.setEnumType(GetChatsResponse_Result, "flipchat.chat.v1.GetChatsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message flipchat.chat.v1.GetChatRequest
 */
export class GetChatRequest extends Message<GetChatRequest> {
  /**
   * @generated from oneof flipchat.chat.v1.GetChatRequest.identifier
   */
  identifier: {
    /**
     * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
     */
    value: ChatId;
    case: "chatId";
  } | {
    /**
     * @generated from field: uint64 room_number = 2;
     */
    value: bigint;
    case: "roomNumber";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: bool exclude_members = 9;
   */
  excludeMembers = false;

  /**
   * Auth is an optional field that authenticates the call, which
   * can be used to fill out extra information in the Metadata.
   *
   * @generated from field: flipchat.common.v1.Auth auth = 10;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<GetChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.GetChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId, oneof: "identifier" },
    { no: 2, name: "room_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "identifier" },
    { no: 9, name: "exclude_members", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatRequest {
    return new GetChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatRequest {
    return new GetChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatRequest {
    return new GetChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatRequest | PlainMessage<GetChatRequest> | undefined, b: GetChatRequest | PlainMessage<GetChatRequest> | undefined): boolean {
    return proto3.util.equals(GetChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.GetChatResponse
 */
export class GetChatResponse extends Message<GetChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.GetChatResponse.Result result = 1;
   */
  result = GetChatResponse_Result.OK;

  /**
   * Metadata is the chat metadata, if result == OK.
   *
   * The contents of the metadata may change whether or not the
   * call was authenticated.
   *
   * @generated from field: flipchat.chat.v1.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * Members contains the chat members, if result == OK and were requested.
   *
   * @generated from field: repeated flipchat.chat.v1.Member members = 3;
   */
  members: Member[] = [];

  constructor(data?: PartialMessage<GetChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.GetChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetChatResponse_Result) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
    { no: 3, name: "members", kind: "message", T: Member, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatResponse {
    return new GetChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatResponse {
    return new GetChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatResponse {
    return new GetChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatResponse | PlainMessage<GetChatResponse> | undefined, b: GetChatResponse | PlainMessage<GetChatResponse> | undefined): boolean {
    return proto3.util.equals(GetChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.GetChatResponse.Result
 */
export enum GetChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatResponse_Result)
proto3.util.setEnumType(GetChatResponse_Result, "flipchat.chat.v1.GetChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message flipchat.chat.v1.StartChatRequest
 */
export class StartChatRequest extends Message<StartChatRequest> {
  /**
   * @generated from oneof flipchat.chat.v1.StartChatRequest.parameters
   */
  parameters: {
    /**
     * @generated from field: flipchat.chat.v1.StartChatRequest.StartTwoWayChatParameters two_way_chat = 1;
     */
    value: StartChatRequest_StartTwoWayChatParameters;
    case: "twoWayChat";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.StartChatRequest.StartGroupChatParameters group_chat = 2;
     */
    value: StartChatRequest_StartGroupChatParameters;
    case: "groupChat";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 10;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<StartChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StartChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "two_way_chat", kind: "message", T: StartChatRequest_StartTwoWayChatParameters, oneof: "parameters" },
    { no: 2, name: "group_chat", kind: "message", T: StartChatRequest_StartGroupChatParameters, oneof: "parameters" },
    { no: 10, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatRequest {
    return new StartChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatRequest {
    return new StartChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatRequest {
    return new StartChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatRequest | PlainMessage<StartChatRequest> | undefined, b: StartChatRequest | PlainMessage<StartChatRequest> | undefined): boolean {
    return proto3.util.equals(StartChatRequest, a, b);
  }
}

/**
 * StartTwoWayChatParameters contains the parameters required to start
 * or recover a two way chat between the caller and the specified 'other_user'.
 *
 * The 'other_user' is currently the 'tip_address', normally retrieved from
 * user.Identity.GetTwitterUser(username).
 *
 * @generated from message flipchat.chat.v1.StartChatRequest.StartTwoWayChatParameters
 */
export class StartChatRequest_StartTwoWayChatParameters extends Message<StartChatRequest_StartTwoWayChatParameters> {
  /**
   * The account id of the user the caller wishes to chat with.
   *
   * @generated from field: flipchat.common.v1.UserId other_user_id = 1;
   */
  otherUserId?: UserId;

  constructor(data?: PartialMessage<StartChatRequest_StartTwoWayChatParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StartChatRequest.StartTwoWayChatParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "other_user_id", kind: "message", T: UserId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatRequest_StartTwoWayChatParameters {
    return new StartChatRequest_StartTwoWayChatParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatRequest_StartTwoWayChatParameters {
    return new StartChatRequest_StartTwoWayChatParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatRequest_StartTwoWayChatParameters {
    return new StartChatRequest_StartTwoWayChatParameters().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatRequest_StartTwoWayChatParameters | PlainMessage<StartChatRequest_StartTwoWayChatParameters> | undefined, b: StartChatRequest_StartTwoWayChatParameters | PlainMessage<StartChatRequest_StartTwoWayChatParameters> | undefined): boolean {
    return proto3.util.equals(StartChatRequest_StartTwoWayChatParameters, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.StartChatRequest.StartGroupChatParameters
 */
export class StartChatRequest_StartGroupChatParameters extends Message<StartChatRequest_StartGroupChatParameters> {
  /**
   * A set of users (not including self) to initially set in the group chat.
   *
   * @generated from field: repeated flipchat.common.v1.UserId users = 1;
   */
  users: UserId[] = [];

  /**
   * Optional display name for the group chat
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * Optional payment for creating the group. It's up to server to decide
   * if the user is allowed to create a group without payment.
   *
   * @generated from field: flipchat.common.v1.IntentId payment_intent = 3;
   */
  paymentIntent?: IntentId;

  constructor(data?: PartialMessage<StartChatRequest_StartGroupChatParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StartChatRequest.StartGroupChatParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "message", T: UserId, repeated: true },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "payment_intent", kind: "message", T: IntentId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatRequest_StartGroupChatParameters {
    return new StartChatRequest_StartGroupChatParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatRequest_StartGroupChatParameters {
    return new StartChatRequest_StartGroupChatParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatRequest_StartGroupChatParameters {
    return new StartChatRequest_StartGroupChatParameters().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatRequest_StartGroupChatParameters | PlainMessage<StartChatRequest_StartGroupChatParameters> | undefined, b: StartChatRequest_StartGroupChatParameters | PlainMessage<StartChatRequest_StartGroupChatParameters> | undefined): boolean {
    return proto3.util.equals(StartChatRequest_StartGroupChatParameters, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.StartChatResponse
 */
export class StartChatResponse extends Message<StartChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.StartChatResponse.Result result = 1;
   */
  result = StartChatResponse_Result.OK;

  /**
   * The chat to use, if result == OK.
   *
   * @generated from field: flipchat.chat.v1.Metadata chat = 2;
   */
  chat?: Metadata;

  /**
   * Members contains the chat members, if result == OK.
   *
   * @generated from field: repeated flipchat.chat.v1.Member members = 3;
   */
  members: Member[] = [];

  constructor(data?: PartialMessage<StartChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StartChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(StartChatResponse_Result) },
    { no: 2, name: "chat", kind: "message", T: Metadata },
    { no: 3, name: "members", kind: "message", T: Member, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatResponse {
    return new StartChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatResponse {
    return new StartChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatResponse {
    return new StartChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatResponse | PlainMessage<StartChatResponse> | undefined, b: StartChatResponse | PlainMessage<StartChatResponse> | undefined): boolean {
    return proto3.util.equals(StartChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.StartChatResponse.Result
 */
export enum StartChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * DENIED indicates the caller is not allowed to start/join the chat.
   *
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * USER_NOT_FOUND indicates that (one of) the target user's was not found.
   *
   * @generated from enum value: USER_NOT_FOUND = 2;
   */
  USER_NOT_FOUND = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StartChatResponse_Result)
proto3.util.setEnumType(StartChatResponse_Result, "flipchat.chat.v1.StartChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "USER_NOT_FOUND" },
]);

/**
 * @generated from message flipchat.chat.v1.StartGroupChatPaymentMetadata
 */
export class StartGroupChatPaymentMetadata extends Message<StartGroupChatPaymentMetadata> {
  /**
   * The user creating the group chat, who will be the initial owner
   *
   * @generated from field: flipchat.common.v1.UserId user_id = 1;
   */
  userId?: UserId;

  constructor(data?: PartialMessage<StartGroupChatPaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.StartGroupChatPaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "message", T: UserId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartGroupChatPaymentMetadata {
    return new StartGroupChatPaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartGroupChatPaymentMetadata {
    return new StartGroupChatPaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartGroupChatPaymentMetadata {
    return new StartGroupChatPaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: StartGroupChatPaymentMetadata | PlainMessage<StartGroupChatPaymentMetadata> | undefined, b: StartGroupChatPaymentMetadata | PlainMessage<StartGroupChatPaymentMetadata> | undefined): boolean {
    return proto3.util.equals(StartGroupChatPaymentMetadata, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.JoinChatRequest
 */
export class JoinChatRequest extends Message<JoinChatRequest> {
  /**
   * @generated from oneof flipchat.chat.v1.JoinChatRequest.identifier
   */
  identifier: {
    /**
     * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
     */
    value: ChatId;
    case: "chatId";
  } | {
    /**
     * @generated from field: uint64 room_id = 2;
     */
    value: bigint;
    case: "roomId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Does the user want to join without the ability to send messages in the chat?
   * If so, then payment_intent is not required? Otherwise, it is.
   *
   * @generated from field: bool without_send_permission = 8;
   */
  withoutSendPermission = false;

  /**
   * The payment for joining a chat, which is required for sending messages in
   * the chat.
   *
   * Note: The chat owner can always bypass payment.
   *
   * @generated from field: flipchat.common.v1.IntentId payment_intent = 9;
   */
  paymentIntent?: IntentId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 10;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<JoinChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.JoinChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId, oneof: "identifier" },
    { no: 2, name: "room_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "identifier" },
    { no: 8, name: "without_send_permission", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "payment_intent", kind: "message", T: IntentId },
    { no: 10, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinChatRequest {
    return new JoinChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinChatRequest {
    return new JoinChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinChatRequest {
    return new JoinChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: JoinChatRequest | PlainMessage<JoinChatRequest> | undefined, b: JoinChatRequest | PlainMessage<JoinChatRequest> | undefined): boolean {
    return proto3.util.equals(JoinChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.JoinChatResponse
 */
export class JoinChatResponse extends Message<JoinChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.JoinChatResponse.Result result = 1;
   */
  result = JoinChatResponse_Result.OK;

  /**
   * The chat metadata, if join was successful.
   *
   * @generated from field: flipchat.chat.v1.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * The members of the chat, if join was successful.
   *
   * @generated from field: repeated flipchat.chat.v1.Member members = 3;
   */
  members: Member[] = [];

  constructor(data?: PartialMessage<JoinChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.JoinChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(JoinChatResponse_Result) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
    { no: 3, name: "members", kind: "message", T: Member, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinChatResponse {
    return new JoinChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinChatResponse {
    return new JoinChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinChatResponse {
    return new JoinChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: JoinChatResponse | PlainMessage<JoinChatResponse> | undefined, b: JoinChatResponse | PlainMessage<JoinChatResponse> | undefined): boolean {
    return proto3.util.equals(JoinChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.JoinChatResponse.Result
 */
export enum JoinChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(JoinChatResponse_Result)
proto3.util.setEnumType(JoinChatResponse_Result, "flipchat.chat.v1.JoinChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.JoinChatPaymentMetadata
 */
export class JoinChatPaymentMetadata extends Message<JoinChatPaymentMetadata> {
  /**
   * The user joining the chat
   *
   * @generated from field: flipchat.common.v1.UserId user_id = 1;
   */
  userId?: UserId;

  /**
   * The chat that the user is joining
   *
   * @generated from field: flipchat.common.v1.ChatId chat_id = 2;
   */
  chatId?: ChatId;

  constructor(data?: PartialMessage<JoinChatPaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.JoinChatPaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "message", T: UserId },
    { no: 2, name: "chat_id", kind: "message", T: ChatId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinChatPaymentMetadata {
    return new JoinChatPaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinChatPaymentMetadata {
    return new JoinChatPaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinChatPaymentMetadata {
    return new JoinChatPaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: JoinChatPaymentMetadata | PlainMessage<JoinChatPaymentMetadata> | undefined, b: JoinChatPaymentMetadata | PlainMessage<JoinChatPaymentMetadata> | undefined): boolean {
    return proto3.util.equals(JoinChatPaymentMetadata, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.LeaveChatRequest
 */
export class LeaveChatRequest extends Message<LeaveChatRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<LeaveChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.LeaveChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LeaveChatRequest {
    return new LeaveChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LeaveChatRequest {
    return new LeaveChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LeaveChatRequest {
    return new LeaveChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LeaveChatRequest | PlainMessage<LeaveChatRequest> | undefined, b: LeaveChatRequest | PlainMessage<LeaveChatRequest> | undefined): boolean {
    return proto3.util.equals(LeaveChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.LeaveChatResponse
 */
export class LeaveChatResponse extends Message<LeaveChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.LeaveChatResponse.Result result = 1;
   */
  result = LeaveChatResponse_Result.OK;

  constructor(data?: PartialMessage<LeaveChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.LeaveChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(LeaveChatResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LeaveChatResponse {
    return new LeaveChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LeaveChatResponse {
    return new LeaveChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LeaveChatResponse {
    return new LeaveChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LeaveChatResponse | PlainMessage<LeaveChatResponse> | undefined, b: LeaveChatResponse | PlainMessage<LeaveChatResponse> | undefined): boolean {
    return proto3.util.equals(LeaveChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.LeaveChatResponse.Result
 */
export enum LeaveChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(LeaveChatResponse_Result)
proto3.util.setEnumType(LeaveChatResponse_Result, "flipchat.chat.v1.LeaveChatResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message flipchat.chat.v1.OpenChatRequest
 */
export class OpenChatRequest extends Message<OpenChatRequest> {
  /**
   * The chat that is being opened
   *
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<OpenChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.OpenChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenChatRequest {
    return new OpenChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenChatRequest {
    return new OpenChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenChatRequest {
    return new OpenChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OpenChatRequest | PlainMessage<OpenChatRequest> | undefined, b: OpenChatRequest | PlainMessage<OpenChatRequest> | undefined): boolean {
    return proto3.util.equals(OpenChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.OpenChatResponse
 */
export class OpenChatResponse extends Message<OpenChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.OpenChatResponse.Result result = 1;
   */
  result = OpenChatResponse_Result.OK;

  constructor(data?: PartialMessage<OpenChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.OpenChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(OpenChatResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenChatResponse {
    return new OpenChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenChatResponse {
    return new OpenChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenChatResponse {
    return new OpenChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: OpenChatResponse | PlainMessage<OpenChatResponse> | undefined, b: OpenChatResponse | PlainMessage<OpenChatResponse> | undefined): boolean {
    return proto3.util.equals(OpenChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.OpenChatResponse.Result
 */
export enum OpenChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(OpenChatResponse_Result)
proto3.util.setEnumType(OpenChatResponse_Result, "flipchat.chat.v1.OpenChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.CloseChatRequest
 */
export class CloseChatRequest extends Message<CloseChatRequest> {
  /**
   * / The chat that is being closed
   *
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<CloseChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.CloseChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseChatRequest {
    return new CloseChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseChatRequest {
    return new CloseChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseChatRequest {
    return new CloseChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CloseChatRequest | PlainMessage<CloseChatRequest> | undefined, b: CloseChatRequest | PlainMessage<CloseChatRequest> | undefined): boolean {
    return proto3.util.equals(CloseChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.CloseChatResponse
 */
export class CloseChatResponse extends Message<CloseChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.CloseChatResponse.Result result = 1;
   */
  result = CloseChatResponse_Result.OK;

  constructor(data?: PartialMessage<CloseChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.CloseChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(CloseChatResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloseChatResponse {
    return new CloseChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseChatResponse {
    return new CloseChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloseChatResponse {
    return new CloseChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CloseChatResponse | PlainMessage<CloseChatResponse> | undefined, b: CloseChatResponse | PlainMessage<CloseChatResponse> | undefined): boolean {
    return proto3.util.equals(CloseChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.CloseChatResponse.Result
 */
export enum CloseChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(CloseChatResponse_Result)
proto3.util.setEnumType(CloseChatResponse_Result, "flipchat.chat.v1.CloseChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.CheckDisplayNameRequest
 */
export class CheckDisplayNameRequest extends Message<CheckDisplayNameRequest> {
  /**
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  constructor(data?: PartialMessage<CheckDisplayNameRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.CheckDisplayNameRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckDisplayNameRequest {
    return new CheckDisplayNameRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckDisplayNameRequest {
    return new CheckDisplayNameRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckDisplayNameRequest {
    return new CheckDisplayNameRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckDisplayNameRequest | PlainMessage<CheckDisplayNameRequest> | undefined, b: CheckDisplayNameRequest | PlainMessage<CheckDisplayNameRequest> | undefined): boolean {
    return proto3.util.equals(CheckDisplayNameRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.CheckDisplayNameResponse
 */
export class CheckDisplayNameResponse extends Message<CheckDisplayNameResponse> {
  /**
   * @generated from field: flipchat.chat.v1.CheckDisplayNameResponse.Result result = 1;
   */
  result = CheckDisplayNameResponse_Result.OK;

  /**
   * @generated from field: bool is_allowed = 2;
   */
  isAllowed = false;

  constructor(data?: PartialMessage<CheckDisplayNameResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.CheckDisplayNameResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(CheckDisplayNameResponse_Result) },
    { no: 2, name: "is_allowed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckDisplayNameResponse {
    return new CheckDisplayNameResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckDisplayNameResponse {
    return new CheckDisplayNameResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckDisplayNameResponse {
    return new CheckDisplayNameResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckDisplayNameResponse | PlainMessage<CheckDisplayNameResponse> | undefined, b: CheckDisplayNameResponse | PlainMessage<CheckDisplayNameResponse> | undefined): boolean {
    return proto3.util.equals(CheckDisplayNameResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.CheckDisplayNameResponse.Result
 */
export enum CheckDisplayNameResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckDisplayNameResponse_Result)
proto3.util.setEnumType(CheckDisplayNameResponse_Result, "flipchat.chat.v1.CheckDisplayNameResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message flipchat.chat.v1.SetDisplayNameRequest
 */
export class SetDisplayNameRequest extends Message<SetDisplayNameRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<SetDisplayNameRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.SetDisplayNameRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetDisplayNameRequest {
    return new SetDisplayNameRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetDisplayNameRequest {
    return new SetDisplayNameRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetDisplayNameRequest {
    return new SetDisplayNameRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetDisplayNameRequest | PlainMessage<SetDisplayNameRequest> | undefined, b: SetDisplayNameRequest | PlainMessage<SetDisplayNameRequest> | undefined): boolean {
    return proto3.util.equals(SetDisplayNameRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.SetDisplayNameResponse
 */
export class SetDisplayNameResponse extends Message<SetDisplayNameResponse> {
  /**
   * @generated from field: flipchat.chat.v1.SetDisplayNameResponse.Result result = 1;
   */
  result = SetDisplayNameResponse_Result.OK;

  /**
   * @generated from field: repeated string alternate_suggestions = 2;
   */
  alternateSuggestions: string[] = [];

  constructor(data?: PartialMessage<SetDisplayNameResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.SetDisplayNameResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetDisplayNameResponse_Result) },
    { no: 2, name: "alternate_suggestions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetDisplayNameResponse {
    return new SetDisplayNameResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetDisplayNameResponse {
    return new SetDisplayNameResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetDisplayNameResponse {
    return new SetDisplayNameResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetDisplayNameResponse | PlainMessage<SetDisplayNameResponse> | undefined, b: SetDisplayNameResponse | PlainMessage<SetDisplayNameResponse> | undefined): boolean {
    return proto3.util.equals(SetDisplayNameResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.SetDisplayNameResponse.Result
 */
export enum SetDisplayNameResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CANT_SET = 2;
   */
  CANT_SET = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetDisplayNameResponse_Result)
proto3.util.setEnumType(SetDisplayNameResponse_Result, "flipchat.chat.v1.SetDisplayNameResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CANT_SET" },
]);

/**
 * @generated from message flipchat.chat.v1.SetCoverChargeRequest
 */
export class SetCoverChargeRequest extends Message<SetCoverChargeRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.PaymentAmount cover_charge = 2;
   */
  coverCharge?: PaymentAmount;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<SetCoverChargeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.SetCoverChargeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "cover_charge", kind: "message", T: PaymentAmount },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCoverChargeRequest {
    return new SetCoverChargeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCoverChargeRequest {
    return new SetCoverChargeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCoverChargeRequest {
    return new SetCoverChargeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetCoverChargeRequest | PlainMessage<SetCoverChargeRequest> | undefined, b: SetCoverChargeRequest | PlainMessage<SetCoverChargeRequest> | undefined): boolean {
    return proto3.util.equals(SetCoverChargeRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.SetCoverChargeResponse
 */
export class SetCoverChargeResponse extends Message<SetCoverChargeResponse> {
  /**
   * @generated from field: flipchat.chat.v1.SetCoverChargeResponse.Result result = 1;
   */
  result = SetCoverChargeResponse_Result.OK;

  constructor(data?: PartialMessage<SetCoverChargeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.SetCoverChargeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetCoverChargeResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCoverChargeResponse {
    return new SetCoverChargeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCoverChargeResponse {
    return new SetCoverChargeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCoverChargeResponse {
    return new SetCoverChargeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetCoverChargeResponse | PlainMessage<SetCoverChargeResponse> | undefined, b: SetCoverChargeResponse | PlainMessage<SetCoverChargeResponse> | undefined): boolean {
    return proto3.util.equals(SetCoverChargeResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.SetCoverChargeResponse.Result
 */
export enum SetCoverChargeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CANT_SET = 2;
   */
  CANT_SET = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetCoverChargeResponse_Result)
proto3.util.setEnumType(SetCoverChargeResponse_Result, "flipchat.chat.v1.SetCoverChargeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CANT_SET" },
]);

/**
 * @generated from message flipchat.chat.v1.SetMessagingFeeRequest
 */
export class SetMessagingFeeRequest extends Message<SetMessagingFeeRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.PaymentAmount messaging_fee = 2;
   */
  messagingFee?: PaymentAmount;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<SetMessagingFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.SetMessagingFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "messaging_fee", kind: "message", T: PaymentAmount },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMessagingFeeRequest {
    return new SetMessagingFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMessagingFeeRequest {
    return new SetMessagingFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMessagingFeeRequest {
    return new SetMessagingFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMessagingFeeRequest | PlainMessage<SetMessagingFeeRequest> | undefined, b: SetMessagingFeeRequest | PlainMessage<SetMessagingFeeRequest> | undefined): boolean {
    return proto3.util.equals(SetMessagingFeeRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.SetMessagingFeeResponse
 */
export class SetMessagingFeeResponse extends Message<SetMessagingFeeResponse> {
  /**
   * @generated from field: flipchat.chat.v1.SetMessagingFeeResponse.Result result = 1;
   */
  result = SetMessagingFeeResponse_Result.OK;

  constructor(data?: PartialMessage<SetMessagingFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.SetMessagingFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetMessagingFeeResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMessagingFeeResponse {
    return new SetMessagingFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMessagingFeeResponse {
    return new SetMessagingFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMessagingFeeResponse {
    return new SetMessagingFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetMessagingFeeResponse | PlainMessage<SetMessagingFeeResponse> | undefined, b: SetMessagingFeeResponse | PlainMessage<SetMessagingFeeResponse> | undefined): boolean {
    return proto3.util.equals(SetMessagingFeeResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.SetMessagingFeeResponse.Result
 */
export enum SetMessagingFeeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CANT_SET = 2;
   */
  CANT_SET = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetMessagingFeeResponse_Result)
proto3.util.setEnumType(SetMessagingFeeResponse_Result, "flipchat.chat.v1.SetMessagingFeeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CANT_SET" },
]);

/**
 * @generated from message flipchat.chat.v1.GetMemberUpdatesRequest
 */
export class GetMemberUpdatesRequest extends Message<GetMemberUpdatesRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * If not provided, a full refresh is performed. Server may also choose
   * to compact updates into a full or individual refresh.
   *
   * @generated from field: flipchat.common.v1.PagingToken paging_token = 2;
   */
  pagingToken?: PagingToken;

  /**
   * Auth is an optional field that authenticates the call, which
   * can be used to fill out extra information.
   *
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<GetMemberUpdatesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.GetMemberUpdatesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "paging_token", kind: "message", T: PagingToken },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMemberUpdatesRequest {
    return new GetMemberUpdatesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMemberUpdatesRequest {
    return new GetMemberUpdatesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMemberUpdatesRequest {
    return new GetMemberUpdatesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMemberUpdatesRequest | PlainMessage<GetMemberUpdatesRequest> | undefined, b: GetMemberUpdatesRequest | PlainMessage<GetMemberUpdatesRequest> | undefined): boolean {
    return proto3.util.equals(GetMemberUpdatesRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.GetMemberUpdatesResponse
 */
export class GetMemberUpdatesResponse extends Message<GetMemberUpdatesResponse> {
  /**
   * @generated from field: flipchat.chat.v1.GetMemberUpdatesResponse.Result result = 1;
   */
  result = GetMemberUpdatesResponse_Result.OK;

  /**
   * @generated from field: repeated flipchat.chat.v1.MemberUpdate updates = 2;
   */
  updates: MemberUpdate[] = [];

  constructor(data?: PartialMessage<GetMemberUpdatesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.GetMemberUpdatesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetMemberUpdatesResponse_Result) },
    { no: 2, name: "updates", kind: "message", T: MemberUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMemberUpdatesResponse {
    return new GetMemberUpdatesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMemberUpdatesResponse {
    return new GetMemberUpdatesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMemberUpdatesResponse {
    return new GetMemberUpdatesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMemberUpdatesResponse | PlainMessage<GetMemberUpdatesResponse> | undefined, b: GetMemberUpdatesResponse | PlainMessage<GetMemberUpdatesResponse> | undefined): boolean {
    return proto3.util.equals(GetMemberUpdatesResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.GetMemberUpdatesResponse.Result
 */
export enum GetMemberUpdatesResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMemberUpdatesResponse_Result)
proto3.util.setEnumType(GetMemberUpdatesResponse_Result, "flipchat.chat.v1.GetMemberUpdatesResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message flipchat.chat.v1.PromoteUserRequest
 */
export class PromoteUserRequest extends Message<PromoteUserRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.UserId user_id = 2;
   */
  userId?: UserId;

  /**
   * Enables send permissions when value is true
   *
   * @generated from field: bool enable_send_permission = 3;
   */
  enableSendPermission = false;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 100;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<PromoteUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.PromoteUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "user_id", kind: "message", T: UserId },
    { no: 3, name: "enable_send_permission", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 100, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromoteUserRequest {
    return new PromoteUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromoteUserRequest {
    return new PromoteUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromoteUserRequest {
    return new PromoteUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PromoteUserRequest | PlainMessage<PromoteUserRequest> | undefined, b: PromoteUserRequest | PlainMessage<PromoteUserRequest> | undefined): boolean {
    return proto3.util.equals(PromoteUserRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.PromoteUserResponse
 */
export class PromoteUserResponse extends Message<PromoteUserResponse> {
  /**
   * @generated from field: flipchat.chat.v1.PromoteUserResponse.Result result = 1;
   */
  result = PromoteUserResponse_Result.OK;

  constructor(data?: PartialMessage<PromoteUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.PromoteUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(PromoteUserResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromoteUserResponse {
    return new PromoteUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromoteUserResponse {
    return new PromoteUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromoteUserResponse {
    return new PromoteUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PromoteUserResponse | PlainMessage<PromoteUserResponse> | undefined, b: PromoteUserResponse | PlainMessage<PromoteUserResponse> | undefined): boolean {
    return proto3.util.equals(PromoteUserResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.PromoteUserResponse.Result
 */
export enum PromoteUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(PromoteUserResponse_Result)
proto3.util.setEnumType(PromoteUserResponse_Result, "flipchat.chat.v1.PromoteUserResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.DemoteUserRequest
 */
export class DemoteUserRequest extends Message<DemoteUserRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.UserId user_id = 2;
   */
  userId?: UserId;

  /**
   * Disables send permissions when value is true
   *
   * @generated from field: bool disable_send_permission = 3;
   */
  disableSendPermission = false;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 100;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<DemoteUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.DemoteUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "user_id", kind: "message", T: UserId },
    { no: 3, name: "disable_send_permission", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 100, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DemoteUserRequest {
    return new DemoteUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DemoteUserRequest {
    return new DemoteUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DemoteUserRequest {
    return new DemoteUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DemoteUserRequest | PlainMessage<DemoteUserRequest> | undefined, b: DemoteUserRequest | PlainMessage<DemoteUserRequest> | undefined): boolean {
    return proto3.util.equals(DemoteUserRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.DemoteUserResponse
 */
export class DemoteUserResponse extends Message<DemoteUserResponse> {
  /**
   * @generated from field: flipchat.chat.v1.DemoteUserResponse.Result result = 1;
   */
  result = DemoteUserResponse_Result.OK;

  constructor(data?: PartialMessage<DemoteUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.DemoteUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(DemoteUserResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DemoteUserResponse {
    return new DemoteUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DemoteUserResponse {
    return new DemoteUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DemoteUserResponse {
    return new DemoteUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DemoteUserResponse | PlainMessage<DemoteUserResponse> | undefined, b: DemoteUserResponse | PlainMessage<DemoteUserResponse> | undefined): boolean {
    return proto3.util.equals(DemoteUserResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.DemoteUserResponse.Result
 */
export enum DemoteUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DemoteUserResponse_Result)
proto3.util.setEnumType(DemoteUserResponse_Result, "flipchat.chat.v1.DemoteUserResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.RemoveUserRequest
 */
export class RemoveUserRequest extends Message<RemoveUserRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.UserId user_id = 2;
   */
  userId?: UserId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<RemoveUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.RemoveUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "user_id", kind: "message", T: UserId },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveUserRequest {
    return new RemoveUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveUserRequest {
    return new RemoveUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveUserRequest {
    return new RemoveUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveUserRequest | PlainMessage<RemoveUserRequest> | undefined, b: RemoveUserRequest | PlainMessage<RemoveUserRequest> | undefined): boolean {
    return proto3.util.equals(RemoveUserRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.RemoveUserResponse
 */
export class RemoveUserResponse extends Message<RemoveUserResponse> {
  /**
   * @generated from field: flipchat.chat.v1.RemoveUserResponse.Result result = 1;
   */
  result = RemoveUserResponse_Result.OK;

  constructor(data?: PartialMessage<RemoveUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.RemoveUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(RemoveUserResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveUserResponse {
    return new RemoveUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveUserResponse {
    return new RemoveUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveUserResponse {
    return new RemoveUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveUserResponse | PlainMessage<RemoveUserResponse> | undefined, b: RemoveUserResponse | PlainMessage<RemoveUserResponse> | undefined): boolean {
    return proto3.util.equals(RemoveUserResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.RemoveUserResponse.Result
 */
export enum RemoveUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RemoveUserResponse_Result)
proto3.util.setEnumType(RemoveUserResponse_Result, "flipchat.chat.v1.RemoveUserResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.MuteUserRequest
 */
export class MuteUserRequest extends Message<MuteUserRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.UserId user_id = 2;
   */
  userId?: UserId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<MuteUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MuteUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "user_id", kind: "message", T: UserId },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MuteUserRequest {
    return new MuteUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MuteUserRequest {
    return new MuteUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MuteUserRequest {
    return new MuteUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MuteUserRequest | PlainMessage<MuteUserRequest> | undefined, b: MuteUserRequest | PlainMessage<MuteUserRequest> | undefined): boolean {
    return proto3.util.equals(MuteUserRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.MuteUserResponse
 */
export class MuteUserResponse extends Message<MuteUserResponse> {
  /**
   * @generated from field: flipchat.chat.v1.MuteUserResponse.Result result = 1;
   */
  result = MuteUserResponse_Result.OK;

  constructor(data?: PartialMessage<MuteUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MuteUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(MuteUserResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MuteUserResponse {
    return new MuteUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MuteUserResponse {
    return new MuteUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MuteUserResponse {
    return new MuteUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MuteUserResponse | PlainMessage<MuteUserResponse> | undefined, b: MuteUserResponse | PlainMessage<MuteUserResponse> | undefined): boolean {
    return proto3.util.equals(MuteUserResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.MuteUserResponse.Result
 */
export enum MuteUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(MuteUserResponse_Result)
proto3.util.setEnumType(MuteUserResponse_Result, "flipchat.chat.v1.MuteUserResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.MuteChatRequest
 */
export class MuteChatRequest extends Message<MuteChatRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<MuteChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MuteChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MuteChatRequest {
    return new MuteChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MuteChatRequest {
    return new MuteChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MuteChatRequest {
    return new MuteChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MuteChatRequest | PlainMessage<MuteChatRequest> | undefined, b: MuteChatRequest | PlainMessage<MuteChatRequest> | undefined): boolean {
    return proto3.util.equals(MuteChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.MuteChatResponse
 */
export class MuteChatResponse extends Message<MuteChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.MuteChatResponse.Result result = 1;
   */
  result = MuteChatResponse_Result.OK;

  constructor(data?: PartialMessage<MuteChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MuteChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(MuteChatResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MuteChatResponse {
    return new MuteChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MuteChatResponse {
    return new MuteChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MuteChatResponse {
    return new MuteChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MuteChatResponse | PlainMessage<MuteChatResponse> | undefined, b: MuteChatResponse | PlainMessage<MuteChatResponse> | undefined): boolean {
    return proto3.util.equals(MuteChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.MuteChatResponse.Result
 */
export enum MuteChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(MuteChatResponse_Result)
proto3.util.setEnumType(MuteChatResponse_Result, "flipchat.chat.v1.MuteChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.UnmuteChatRequest
 */
export class UnmuteChatRequest extends Message<UnmuteChatRequest> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<UnmuteChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.UnmuteChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnmuteChatRequest {
    return new UnmuteChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnmuteChatRequest {
    return new UnmuteChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnmuteChatRequest {
    return new UnmuteChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnmuteChatRequest | PlainMessage<UnmuteChatRequest> | undefined, b: UnmuteChatRequest | PlainMessage<UnmuteChatRequest> | undefined): boolean {
    return proto3.util.equals(UnmuteChatRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.UnmuteChatResponse
 */
export class UnmuteChatResponse extends Message<UnmuteChatResponse> {
  /**
   * @generated from field: flipchat.chat.v1.UnmuteChatResponse.Result result = 1;
   */
  result = UnmuteChatResponse_Result.OK;

  constructor(data?: PartialMessage<UnmuteChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.UnmuteChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(UnmuteChatResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnmuteChatResponse {
    return new UnmuteChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnmuteChatResponse {
    return new UnmuteChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnmuteChatResponse {
    return new UnmuteChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnmuteChatResponse | PlainMessage<UnmuteChatResponse> | undefined, b: UnmuteChatResponse | PlainMessage<UnmuteChatResponse> | undefined): boolean {
    return proto3.util.equals(UnmuteChatResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.UnmuteChatResponse.Result
 */
export enum UnmuteChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(UnmuteChatResponse_Result)
proto3.util.setEnumType(UnmuteChatResponse_Result, "flipchat.chat.v1.UnmuteChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message flipchat.chat.v1.ReportUserRequest
 */
export class ReportUserRequest extends Message<ReportUserRequest> {
  /**
   * @generated from field: flipchat.common.v1.UserId user_id = 1;
   */
  userId?: UserId;

  /**
   * @generated from field: flipchat.messaging.v1.MessageId message_id = 2;
   */
  messageId?: MessageId;

  /**
   * @generated from field: flipchat.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<ReportUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.ReportUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "message", T: UserId },
    { no: 2, name: "message_id", kind: "message", T: MessageId },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportUserRequest {
    return new ReportUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportUserRequest {
    return new ReportUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportUserRequest {
    return new ReportUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReportUserRequest | PlainMessage<ReportUserRequest> | undefined, b: ReportUserRequest | PlainMessage<ReportUserRequest> | undefined): boolean {
    return proto3.util.equals(ReportUserRequest, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.ReportUserResponse
 */
export class ReportUserResponse extends Message<ReportUserResponse> {
  /**
   * @generated from field: flipchat.chat.v1.ReportUserResponse.Result result = 1;
   */
  result = ReportUserResponse_Result.OK;

  constructor(data?: PartialMessage<ReportUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.ReportUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(ReportUserResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportUserResponse {
    return new ReportUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportUserResponse {
    return new ReportUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportUserResponse {
    return new ReportUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReportUserResponse | PlainMessage<ReportUserResponse> | undefined, b: ReportUserResponse | PlainMessage<ReportUserResponse> | undefined): boolean {
    return proto3.util.equals(ReportUserResponse, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.ReportUserResponse.Result
 */
export enum ReportUserResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(ReportUserResponse_Result)
proto3.util.setEnumType(ReportUserResponse_Result, "flipchat.chat.v1.ReportUserResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message flipchat.chat.v1.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from field: flipchat.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * The type of chat
   *
   * @generated from field: flipchat.chat.v1.Metadata.ChatType type = 2;
   */
  type = Metadata_ChatType.UNKNOWN;

  /**
   * The chat display name
   *
   * @generated from field: string display_name = 3;
   */
  displayName = "";

  /**
   * If non-zero, the room number associated with the chat.
   *
   * @generated from field: uint64 room_number = 4;
   */
  roomNumber = protoInt64.zero;

  /**
   * Are push notifications enabled for this chat (from the perspective of the caller)?
   *
   * @generated from field: bool is_push_enabled = 5;
   */
  isPushEnabled = false;

  /**
   * Can the user disable push notifications for this chat using MuteChat?
   *
   * @generated from field: bool can_disable_push = 6;
   */
  canDisablePush = false;

  /**
   * Number of (estimated) unread message (from the perspective of the caller).
   *
   * @generated from field: uint32 num_unread = 7;
   */
  numUnread = 0;

  /**
   * If there are more unread messages than indicated by num_unread. If this is
   * true, client should show num_unread+ as the unread count.
   *
   * @generated from field: bool has_more_unread = 11;
   */
  hasMoreUnread = false;

  /**
   * Owner is the owner/creator of the chat.
   *
   * This is a super priviledge role, in which there can only be one.
   * This role is displayed as a 'host' currently.
   *
   * @generated from field: flipchat.common.v1.UserId owner = 8;
   */
  owner?: UserId;

  /**
   * If present, the fee that must be paid to send a message as a non-regular
   * chat member.
   *
   * This replaces the legacy cover charge mechanic, which is deprecated
   *
   * @generated from field: flipchat.common.v1.PaymentAmount messaging_fee = 9;
   */
  messagingFee?: PaymentAmount;

  /**
   * The timestamp of the last activity in this chat
   *
   * @generated from field: google.protobuf.Timestamp last_activity = 10;
   */
  lastActivity?: Timestamp;

  /**
   * The status as to whether the room is open or closed. This may be
   * omitted for chats where it doesn't apply. If not provided, it's
   * safe to assume the chat is open indefinitely until otherwise provided.
   *
   * @generated from field: flipchat.chat.v1.OpenStatus open_status = 12;
   */
  openStatus?: OpenStatus;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(Metadata_ChatType) },
    { no: 3, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "room_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "is_push_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "can_disable_push", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "num_unread", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "has_more_unread", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "owner", kind: "message", T: UserId },
    { no: 9, name: "messaging_fee", kind: "message", T: PaymentAmount },
    { no: 10, name: "last_activity", kind: "message", T: Timestamp },
    { no: 12, name: "open_status", kind: "message", T: OpenStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * @generated from enum flipchat.chat.v1.Metadata.ChatType
 */
export enum Metadata_ChatType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: TWO_WAY = 1;
   */
  TWO_WAY = 1,

  /**
   * @generated from enum value: GROUP = 2;
   */
  GROUP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Metadata_ChatType)
proto3.util.setEnumType(Metadata_ChatType, "flipchat.chat.v1.Metadata.ChatType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "TWO_WAY" },
  { no: 2, name: "GROUP" },
]);

/**
 * todo: In the future, we may add additional fields like open/closed until a timestamp, etc.
 *       For backwards compatibility, client can always refer to is_currently_open for whether
 *       a room is open right now or not for the purposes of sending messages.
 * todo: A better name for this
 *
 * @generated from message flipchat.chat.v1.OpenStatus
 */
export class OpenStatus extends Message<OpenStatus> {
  /**
   * @generated from field: bool is_currently_open = 1;
   */
  isCurrentlyOpen = false;

  constructor(data?: PartialMessage<OpenStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.OpenStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_currently_open", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenStatus {
    return new OpenStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenStatus {
    return new OpenStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenStatus {
    return new OpenStatus().fromJsonString(jsonString, options);
  }

  static equals(a: OpenStatus | PlainMessage<OpenStatus> | undefined, b: OpenStatus | PlainMessage<OpenStatus> | undefined): boolean {
    return proto3.util.equals(OpenStatus, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.MetadataUpdate
 */
export class MetadataUpdate extends Message<MetadataUpdate> {
  /**
   * @generated from oneof flipchat.chat.v1.MetadataUpdate.kind
   */
  kind: {
    /**
     * @generated from field: flipchat.chat.v1.MetadataUpdate.FullRefresh full_refresh = 1;
     */
    value: MetadataUpdate_FullRefresh;
    case: "fullRefresh";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MetadataUpdate.UnreadCountChanged unread_count_changed = 2;
     */
    value: MetadataUpdate_UnreadCountChanged;
    case: "unreadCountChanged";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MetadataUpdate.DisplayNameChanged display_name_changed = 3;
     */
    value: MetadataUpdate_DisplayNameChanged;
    case: "displayNameChanged";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MetadataUpdate.MessagingFeeChanged messaging_fee_changed = 4;
     */
    value: MetadataUpdate_MessagingFeeChanged;
    case: "messagingFeeChanged";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MetadataUpdate.LastActivityChanged last_activity_changed = 5;
     */
    value: MetadataUpdate_LastActivityChanged;
    case: "lastActivityChanged";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MetadataUpdate.OpenStatusChanged open_status_changed = 6;
     */
    value: MetadataUpdate_OpenStatusChanged;
    case: "openStatusChanged";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MetadataUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "full_refresh", kind: "message", T: MetadataUpdate_FullRefresh, oneof: "kind" },
    { no: 2, name: "unread_count_changed", kind: "message", T: MetadataUpdate_UnreadCountChanged, oneof: "kind" },
    { no: 3, name: "display_name_changed", kind: "message", T: MetadataUpdate_DisplayNameChanged, oneof: "kind" },
    { no: 4, name: "messaging_fee_changed", kind: "message", T: MetadataUpdate_MessagingFeeChanged, oneof: "kind" },
    { no: 5, name: "last_activity_changed", kind: "message", T: MetadataUpdate_LastActivityChanged, oneof: "kind" },
    { no: 6, name: "open_status_changed", kind: "message", T: MetadataUpdate_OpenStatusChanged, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate {
    return new MetadataUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate {
    return new MetadataUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate {
    return new MetadataUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate | PlainMessage<MetadataUpdate> | undefined, b: MetadataUpdate | PlainMessage<MetadataUpdate> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate, a, b);
  }
}

/**
 * Refreshes the entire chat metadata
 *
 * @generated from message flipchat.chat.v1.MetadataUpdate.FullRefresh
 */
export class MetadataUpdate_FullRefresh extends Message<MetadataUpdate_FullRefresh> {
  /**
   * @generated from field: flipchat.chat.v1.Metadata metadata = 1;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<MetadataUpdate_FullRefresh>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate.FullRefresh";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate_FullRefresh {
    return new MetadataUpdate_FullRefresh().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate_FullRefresh {
    return new MetadataUpdate_FullRefresh().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate_FullRefresh {
    return new MetadataUpdate_FullRefresh().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate_FullRefresh | PlainMessage<MetadataUpdate_FullRefresh> | undefined, b: MetadataUpdate_FullRefresh | PlainMessage<MetadataUpdate_FullRefresh> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate_FullRefresh, a, b);
  }
}

/**
 * New message in the chat has generated a new unread count
 *
 * @generated from message flipchat.chat.v1.MetadataUpdate.UnreadCountChanged
 */
export class MetadataUpdate_UnreadCountChanged extends Message<MetadataUpdate_UnreadCountChanged> {
  /**
   * Number of (estimated) unread message
   *
   * @generated from field: uint32 num_unread = 1;
   */
  numUnread = 0;

  /**
   * If there are more unread messages than indicated by num_unread.
   * If this is true, client should show num_unread+ as the unread count.
   *
   * @generated from field: bool has_more_unread = 2;
   */
  hasMoreUnread = false;

  constructor(data?: PartialMessage<MetadataUpdate_UnreadCountChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate.UnreadCountChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_unread", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "has_more_unread", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate_UnreadCountChanged {
    return new MetadataUpdate_UnreadCountChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate_UnreadCountChanged {
    return new MetadataUpdate_UnreadCountChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate_UnreadCountChanged {
    return new MetadataUpdate_UnreadCountChanged().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate_UnreadCountChanged | PlainMessage<MetadataUpdate_UnreadCountChanged> | undefined, b: MetadataUpdate_UnreadCountChanged | PlainMessage<MetadataUpdate_UnreadCountChanged> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate_UnreadCountChanged, a, b);
  }
}

/**
 * The chat display name has been updated to a new value
 *
 * @generated from message flipchat.chat.v1.MetadataUpdate.DisplayNameChanged
 */
export class MetadataUpdate_DisplayNameChanged extends Message<MetadataUpdate_DisplayNameChanged> {
  /**
   * @generated from field: string new_display_name = 1;
   */
  newDisplayName = "";

  constructor(data?: PartialMessage<MetadataUpdate_DisplayNameChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate.DisplayNameChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate_DisplayNameChanged {
    return new MetadataUpdate_DisplayNameChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate_DisplayNameChanged {
    return new MetadataUpdate_DisplayNameChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate_DisplayNameChanged {
    return new MetadataUpdate_DisplayNameChanged().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate_DisplayNameChanged | PlainMessage<MetadataUpdate_DisplayNameChanged> | undefined, b: MetadataUpdate_DisplayNameChanged | PlainMessage<MetadataUpdate_DisplayNameChanged> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate_DisplayNameChanged, a, b);
  }
}

/**
 * The chat messaging fee has been updated to a new value
 *
 * @generated from message flipchat.chat.v1.MetadataUpdate.MessagingFeeChanged
 */
export class MetadataUpdate_MessagingFeeChanged extends Message<MetadataUpdate_MessagingFeeChanged> {
  /**
   * @generated from field: flipchat.common.v1.PaymentAmount new_messaging_fee = 1;
   */
  newMessagingFee?: PaymentAmount;

  constructor(data?: PartialMessage<MetadataUpdate_MessagingFeeChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate.MessagingFeeChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_messaging_fee", kind: "message", T: PaymentAmount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate_MessagingFeeChanged {
    return new MetadataUpdate_MessagingFeeChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate_MessagingFeeChanged {
    return new MetadataUpdate_MessagingFeeChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate_MessagingFeeChanged {
    return new MetadataUpdate_MessagingFeeChanged().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate_MessagingFeeChanged | PlainMessage<MetadataUpdate_MessagingFeeChanged> | undefined, b: MetadataUpdate_MessagingFeeChanged | PlainMessage<MetadataUpdate_MessagingFeeChanged> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate_MessagingFeeChanged, a, b);
  }
}

/**
 * The last activity timestamp has changed to a newer value
 *
 * @generated from message flipchat.chat.v1.MetadataUpdate.LastActivityChanged
 */
export class MetadataUpdate_LastActivityChanged extends Message<MetadataUpdate_LastActivityChanged> {
  /**
   * @generated from field: google.protobuf.Timestamp new_last_activity = 1;
   */
  newLastActivity?: Timestamp;

  constructor(data?: PartialMessage<MetadataUpdate_LastActivityChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate.LastActivityChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_last_activity", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate_LastActivityChanged {
    return new MetadataUpdate_LastActivityChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate_LastActivityChanged {
    return new MetadataUpdate_LastActivityChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate_LastActivityChanged {
    return new MetadataUpdate_LastActivityChanged().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate_LastActivityChanged | PlainMessage<MetadataUpdate_LastActivityChanged> | undefined, b: MetadataUpdate_LastActivityChanged | PlainMessage<MetadataUpdate_LastActivityChanged> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate_LastActivityChanged, a, b);
  }
}

/**
 * The open status has changed to a newer value
 *
 * @generated from message flipchat.chat.v1.MetadataUpdate.OpenStatusChanged
 */
export class MetadataUpdate_OpenStatusChanged extends Message<MetadataUpdate_OpenStatusChanged> {
  /**
   * @generated from field: flipchat.chat.v1.OpenStatus new_open_status = 1;
   */
  newOpenStatus?: OpenStatus;

  constructor(data?: PartialMessage<MetadataUpdate_OpenStatusChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MetadataUpdate.OpenStatusChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_open_status", kind: "message", T: OpenStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataUpdate_OpenStatusChanged {
    return new MetadataUpdate_OpenStatusChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataUpdate_OpenStatusChanged {
    return new MetadataUpdate_OpenStatusChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataUpdate_OpenStatusChanged {
    return new MetadataUpdate_OpenStatusChanged().fromJsonString(jsonString, options);
  }

  static equals(a: MetadataUpdate_OpenStatusChanged | PlainMessage<MetadataUpdate_OpenStatusChanged> | undefined, b: MetadataUpdate_OpenStatusChanged | PlainMessage<MetadataUpdate_OpenStatusChanged> | undefined): boolean {
    return proto3.util.equals(MetadataUpdate_OpenStatusChanged, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.Member
 */
export class Member extends Message<Member> {
  /**
   * @generated from field: flipchat.common.v1.UserId user_id = 1;
   */
  userId?: UserId;

  /**
   * The chat member's identity/profile information.
   *
   * It is a light weight version of the users full profile, which
   * can be retrieved from the Profile service.
   *
   * @generated from field: flipchat.chat.v1.MemberIdentity identity = 2;
   */
  identity?: MemberIdentity;

  /**
   * Chat message state for this member.
   *
   * If set, the list may contain DELIVERED and READ pointers. SENT pointers
   * are only shared between the sender and server, to indicate persistence.
   *
   * The server may wish to omit all pointers in various types of group chats
   * or as relief valves.
   *
   * @generated from field: repeated flipchat.messaging.v1.Pointer pointers = 3;
   */
  pointers: Pointer[] = [];

  /**
   * If the member is the caller (where applicable), will be set to true.
   *
   * @generated from field: bool is_self = 4;
   */
  isSelf = false;

  /**
   * Does the chat member have permission to perform moderation actions in
   * the chat?
   *
   * @generated from field: bool has_moderator_permission = 5;
   */
  hasModeratorPermission = false;

  /**
   * Has the chat member been muted by a moderator? If so, they cannot send
   * messages, even if they paid for the permission.
   *
   * @generated from field: bool is_muted = 6;
   */
  isMuted = false;

  /**
   * Does the chat member have permission to send messages in the chat? If
   * not, the user is considered to be a spectator or listener. Otherwise,
   * they are a speaker.
   *
   * @generated from field: bool has_send_permission = 7;
   */
  hasSendPermission = false;

  constructor(data?: PartialMessage<Member>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.Member";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "message", T: UserId },
    { no: 2, name: "identity", kind: "message", T: MemberIdentity },
    { no: 3, name: "pointers", kind: "message", T: Pointer, repeated: true },
    { no: 4, name: "is_self", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "has_moderator_permission", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "has_send_permission", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Member {
    return new Member().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJsonString(jsonString, options);
  }

  static equals(a: Member | PlainMessage<Member> | undefined, b: Member | PlainMessage<Member> | undefined): boolean {
    return proto3.util.equals(Member, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.MemberIdentity
 */
export class MemberIdentity extends Message<MemberIdentity> {
  /**
   * If present, the display name of the user.
   *
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  /**
   * If present, the URL of the users profile pic.
   *
   * @generated from field: string profile_pic_url = 2;
   */
  profilePicUrl = "";

  /**
   * The linked social profiles of the user
   *
   * @generated from field: repeated flipchat.profile.v1.SocialProfile social_profiles = 3;
   */
  socialProfiles: SocialProfile[] = [];

  constructor(data?: PartialMessage<MemberIdentity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberIdentity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "profile_pic_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "social_profiles", kind: "message", T: SocialProfile, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberIdentity {
    return new MemberIdentity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberIdentity {
    return new MemberIdentity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberIdentity {
    return new MemberIdentity().fromJsonString(jsonString, options);
  }

  static equals(a: MemberIdentity | PlainMessage<MemberIdentity> | undefined, b: MemberIdentity | PlainMessage<MemberIdentity> | undefined): boolean {
    return proto3.util.equals(MemberIdentity, a, b);
  }
}

/**
 * @generated from message flipchat.chat.v1.MemberUpdate
 */
export class MemberUpdate extends Message<MemberUpdate> {
  /**
   * @generated from oneof flipchat.chat.v1.MemberUpdate.kind
   */
  kind: {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.FullRefresh full_refresh = 1;
     */
    value: MemberUpdate_FullRefresh;
    case: "fullRefresh";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.IndividualRefresh individual_refresh = 2;
     */
    value: MemberUpdate_IndividualRefresh;
    case: "individualRefresh";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.Joined joined = 3;
     */
    value: MemberUpdate_Joined;
    case: "joined";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.Left left = 4;
     */
    value: MemberUpdate_Left;
    case: "left";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.Removed removed = 5;
     */
    value: MemberUpdate_Removed;
    case: "removed";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.Muted muted = 6;
     */
    value: MemberUpdate_Muted;
    case: "muted";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.Promoted promoted = 7;
     */
    value: MemberUpdate_Promoted;
    case: "promoted";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.Demoted demoted = 8;
     */
    value: MemberUpdate_Demoted;
    case: "demoted";
  } | {
    /**
     * @generated from field: flipchat.chat.v1.MemberUpdate.IdentityChanged identity_changed = 9;
     */
    value: MemberUpdate_IdentityChanged;
    case: "identityChanged";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: flipchat.common.v1.PagingToken paging_token = 1000;
   */
  pagingToken?: PagingToken;

  constructor(data?: PartialMessage<MemberUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "full_refresh", kind: "message", T: MemberUpdate_FullRefresh, oneof: "kind" },
    { no: 2, name: "individual_refresh", kind: "message", T: MemberUpdate_IndividualRefresh, oneof: "kind" },
    { no: 3, name: "joined", kind: "message", T: MemberUpdate_Joined, oneof: "kind" },
    { no: 4, name: "left", kind: "message", T: MemberUpdate_Left, oneof: "kind" },
    { no: 5, name: "removed", kind: "message", T: MemberUpdate_Removed, oneof: "kind" },
    { no: 6, name: "muted", kind: "message", T: MemberUpdate_Muted, oneof: "kind" },
    { no: 7, name: "promoted", kind: "message", T: MemberUpdate_Promoted, oneof: "kind" },
    { no: 8, name: "demoted", kind: "message", T: MemberUpdate_Demoted, oneof: "kind" },
    { no: 9, name: "identity_changed", kind: "message", T: MemberUpdate_IdentityChanged, oneof: "kind" },
    { no: 1000, name: "paging_token", kind: "message", T: PagingToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate {
    return new MemberUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate {
    return new MemberUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate {
    return new MemberUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate | PlainMessage<MemberUpdate> | undefined, b: MemberUpdate | PlainMessage<MemberUpdate> | undefined): boolean {
    return proto3.util.equals(MemberUpdate, a, b);
  }
}

/**
 * Refreshes the state of the entire chat membership
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.FullRefresh
 */
export class MemberUpdate_FullRefresh extends Message<MemberUpdate_FullRefresh> {
  /**
   * @generated from field: repeated flipchat.chat.v1.Member members = 1;
   */
  members: Member[] = [];

  constructor(data?: PartialMessage<MemberUpdate_FullRefresh>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.FullRefresh";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "message", T: Member, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_FullRefresh {
    return new MemberUpdate_FullRefresh().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_FullRefresh {
    return new MemberUpdate_FullRefresh().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_FullRefresh {
    return new MemberUpdate_FullRefresh().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_FullRefresh | PlainMessage<MemberUpdate_FullRefresh> | undefined, b: MemberUpdate_FullRefresh | PlainMessage<MemberUpdate_FullRefresh> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_FullRefresh, a, b);
  }
}

/**
 * Refreshes the state of an individual member in the chat
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.IndividualRefresh
 */
export class MemberUpdate_IndividualRefresh extends Message<MemberUpdate_IndividualRefresh> {
  /**
   * @generated from field: flipchat.chat.v1.Member member = 1;
   */
  member?: Member;

  constructor(data?: PartialMessage<MemberUpdate_IndividualRefresh>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.IndividualRefresh";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: Member },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_IndividualRefresh {
    return new MemberUpdate_IndividualRefresh().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_IndividualRefresh {
    return new MemberUpdate_IndividualRefresh().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_IndividualRefresh {
    return new MemberUpdate_IndividualRefresh().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_IndividualRefresh | PlainMessage<MemberUpdate_IndividualRefresh> | undefined, b: MemberUpdate_IndividualRefresh | PlainMessage<MemberUpdate_IndividualRefresh> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_IndividualRefresh, a, b);
  }
}

/**
 * Member joined the chat via the JoinChat RPC
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.Joined
 */
export class MemberUpdate_Joined extends Message<MemberUpdate_Joined> {
  /**
   * @generated from field: flipchat.chat.v1.Member member = 1;
   */
  member?: Member;

  constructor(data?: PartialMessage<MemberUpdate_Joined>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.Joined";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: Member },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_Joined {
    return new MemberUpdate_Joined().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_Joined {
    return new MemberUpdate_Joined().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_Joined {
    return new MemberUpdate_Joined().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_Joined | PlainMessage<MemberUpdate_Joined> | undefined, b: MemberUpdate_Joined | PlainMessage<MemberUpdate_Joined> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_Joined, a, b);
  }
}

/**
 * Member left the chat via the LeaveChat RPC
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.Left
 */
export class MemberUpdate_Left extends Message<MemberUpdate_Left> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  constructor(data?: PartialMessage<MemberUpdate_Left>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.Left";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_Left {
    return new MemberUpdate_Left().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_Left {
    return new MemberUpdate_Left().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_Left {
    return new MemberUpdate_Left().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_Left | PlainMessage<MemberUpdate_Left> | undefined, b: MemberUpdate_Left | PlainMessage<MemberUpdate_Left> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_Left, a, b);
  }
}

/**
 * Member was removed from the chat via the RemoveUser RPC
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.Removed
 */
export class MemberUpdate_Removed extends Message<MemberUpdate_Removed> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  /**
   * @generated from field: flipchat.common.v1.UserId removed_by = 2;
   */
  removedBy?: UserId;

  constructor(data?: PartialMessage<MemberUpdate_Removed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.Removed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
    { no: 2, name: "removed_by", kind: "message", T: UserId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_Removed {
    return new MemberUpdate_Removed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_Removed {
    return new MemberUpdate_Removed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_Removed {
    return new MemberUpdate_Removed().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_Removed | PlainMessage<MemberUpdate_Removed> | undefined, b: MemberUpdate_Removed | PlainMessage<MemberUpdate_Removed> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_Removed, a, b);
  }
}

/**
 * Member was muted in the chat via the MuteUser RPC
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.Muted
 */
export class MemberUpdate_Muted extends Message<MemberUpdate_Muted> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  /**
   * @generated from field: flipchat.common.v1.UserId muted_by = 2;
   */
  mutedBy?: UserId;

  constructor(data?: PartialMessage<MemberUpdate_Muted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.Muted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
    { no: 2, name: "muted_by", kind: "message", T: UserId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_Muted {
    return new MemberUpdate_Muted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_Muted {
    return new MemberUpdate_Muted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_Muted {
    return new MemberUpdate_Muted().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_Muted | PlainMessage<MemberUpdate_Muted> | undefined, b: MemberUpdate_Muted | PlainMessage<MemberUpdate_Muted> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_Muted, a, b);
  }
}

/**
 * Member was promoted in the chat via the PromoteUser RPC
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.Promoted
 */
export class MemberUpdate_Promoted extends Message<MemberUpdate_Promoted> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  /**
   * @generated from field: flipchat.common.v1.UserId promoted_by = 2;
   */
  promotedBy?: UserId;

  /**
   * @generated from field: bool send_permission_enabled = 3;
   */
  sendPermissionEnabled = false;

  constructor(data?: PartialMessage<MemberUpdate_Promoted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.Promoted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
    { no: 2, name: "promoted_by", kind: "message", T: UserId },
    { no: 3, name: "send_permission_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_Promoted {
    return new MemberUpdate_Promoted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_Promoted {
    return new MemberUpdate_Promoted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_Promoted {
    return new MemberUpdate_Promoted().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_Promoted | PlainMessage<MemberUpdate_Promoted> | undefined, b: MemberUpdate_Promoted | PlainMessage<MemberUpdate_Promoted> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_Promoted, a, b);
  }
}

/**
 * Member was demoted in the chat via the DemoteUser RPC
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.Demoted
 */
export class MemberUpdate_Demoted extends Message<MemberUpdate_Demoted> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  /**
   * @generated from field: flipchat.common.v1.UserId demoted_by = 2;
   */
  demotedBy?: UserId;

  /**
   * @generated from field: bool send_permission_disabled = 3;
   */
  sendPermissionDisabled = false;

  constructor(data?: PartialMessage<MemberUpdate_Demoted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.Demoted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
    { no: 2, name: "demoted_by", kind: "message", T: UserId },
    { no: 3, name: "send_permission_disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_Demoted {
    return new MemberUpdate_Demoted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_Demoted {
    return new MemberUpdate_Demoted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_Demoted {
    return new MemberUpdate_Demoted().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_Demoted | PlainMessage<MemberUpdate_Demoted> | undefined, b: MemberUpdate_Demoted | PlainMessage<MemberUpdate_Demoted> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_Demoted, a, b);
  }
}

/**
 * Member identity has changed
 *
 * @generated from message flipchat.chat.v1.MemberUpdate.IdentityChanged
 */
export class MemberUpdate_IdentityChanged extends Message<MemberUpdate_IdentityChanged> {
  /**
   * @generated from field: flipchat.common.v1.UserId member = 1;
   */
  member?: UserId;

  /**
   * @generated from field: flipchat.chat.v1.MemberIdentity new_identity = 2;
   */
  newIdentity?: MemberIdentity;

  constructor(data?: PartialMessage<MemberUpdate_IdentityChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipchat.chat.v1.MemberUpdate.IdentityChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member", kind: "message", T: UserId },
    { no: 2, name: "new_identity", kind: "message", T: MemberIdentity },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberUpdate_IdentityChanged {
    return new MemberUpdate_IdentityChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberUpdate_IdentityChanged {
    return new MemberUpdate_IdentityChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberUpdate_IdentityChanged {
    return new MemberUpdate_IdentityChanged().fromJsonString(jsonString, options);
  }

  static equals(a: MemberUpdate_IdentityChanged | PlainMessage<MemberUpdate_IdentityChanged> | undefined, b: MemberUpdate_IdentityChanged | PlainMessage<MemberUpdate_IdentityChanged> | undefined): boolean {
    return proto3.util.equals(MemberUpdate_IdentityChanged, a, b);
  }
}

